#pragma once

#include <fstream>

#include "fgt.hpp"

namespace fgt {
namespace {

const char* TEST_DATA_DIR = "@PROJECT_SOURCE_DIR@/test/data/";
}

std::string project_source_filename(const std::string& filename) {
    return "@PROJECT_SOURCE_DIR@/" + filename;
}

template <typename T>
struct Matrix {
    std::vector<T> data;
    size_t rows;
    size_t cols;
};

template <typename T>
Matrix<T> load_ascii_test_matrix(const std::string& filename) {
    std::ifstream file(TEST_DATA_DIR + filename);
    if (!file.is_open()) {
        std::stringstream msg;
        msg << "Unable to open test data file: " << filename;
        throw std::runtime_error(msg.str());
    }
    std::vector<T> data;
    size_t rows = 0;
    size_t cols = 0;
    std::string line;
    while (std::getline(file, line)) {
        std::stringstream ss(line);
        T value = 0.0;
        size_t nvalues = 0;
        while (ss >> value) {
            data.push_back(value);
            ++nvalues;
        }
        if (cols == 0) {
            cols = nvalues;
        } else if (cols != nvalues) {
            std::stringstream msg;
            msg << "Dimension mismatch (" << cols << ", " << nvalues;
            throw std::runtime_error(msg.str());
        }
        ++rows;
    }
    return {data, rows, cols};
}

template <typename T>
Matrix<T> load_binary_test_matrix(const std::string& filename, size_t rows,
                                  size_t cols) {
    std::ifstream file(TEST_DATA_DIR + filename);
    if (!file.is_open()) {
        std::stringstream msg;
        msg << "Unable to open test data file: " << filename;
        throw std::runtime_error(msg.str());
    }
    std::vector<T> data(rows * cols);
    file.read(reinterpret_cast<char*>(data.data()), rows * cols * sizeof(T));
    file.close();
    return {data, rows, cols};
}
}
